let s = "Knowledge, of built-in JavaScript methods, speeds up a tester's work.";
let newS;

console.log(s);
// Output: "Knowledge, of built-in JavaScript methods, speeds up a tester's work."

newS = s.length;
// Returns the length of the string
// Output: 69

newS = s.charAt(0);
// Returns the character at index 0
// Output: "K"

newS = s[0];
// Another way to get the character at index 0
// Output: "K"

newS = s.charCodeAt(0);
// Returns the Unicode of the character at index 0
// Output: 75

newS = s.at(0);
// Returns the character at index 0 (ES2022 feature)
// Output: "K"

newS = s.charAt(s.length - 3);
// Returns the third character from the end
// Output: "o"

newS = s.substring(2, 5);
// Extracts characters from index 2 to 4
// Output: "owl"

newS = s.substr(1, 3);
// Extracts 3 characters starting from index 1 (Deprecated)
// Output: "now"

newS = s.slice(1, 4);
// can also use negative num
// Extracts characters from index 1 to 3
// Output: "now"

newS = s.slice(-3);
// Extracts the last 3 c
// Sorting strings:
//   let c = [a, b];
//   c.sort((x, y) => x.length - y.length);


// const name = "James";
// switch (name){
//     case "Mark":
//         console.log("Hi");
//     case "James":
//         console.log("Bye");
//         break;
//     default:
//         console.log("Yes");
// }


// break, continue
// do {} while()
// try, catch, finally

// Math
// Math.abs Math.floor Math.ceil Math.random, Math.min Math.max

// General methods
// num.toString() -> int to str
// isNaN <- if its not int isNan(23)
// isInteger -> check if its int
// toFixed -> round (35).toFixed(2) - > 35.00
// parseInt <- str to int


//map, reduce, filter
// divisibleBy = (n, f) => n.filter(num => num % f === 0)
// name.split(' ').map(i => i[0].toUpperCase()).join('.')


// Set
// set-> has()
// "#".repeat(cc.slice(0, -4).length)


// Lists/array
// concat() <- expand list
// push -> end 
// unshift -> beginning 
// pop last
// shift -> first pop
// delete arr[2] index delete makes empty but doesnt shortens arr
// .at -> we can use negative numbers for the ind from the end
// toString() -> arr to str
// .split() <- need to input space by default
// .join() <- arr to string
// JSON.stringify <- to compare arrs

// arr1.concat(arr2) <- extend arr
// arr = [...ar1, ...ar2] <- extend too
// arr = [...ar, ...(isSummer? [1,2,3]:[])]
// str to arr-> [...str]

//Sorting Arrs
//numbers.sort((a, b) => a - b); // Ascending
//numbers.sort((a, b) => b - a); // Descending
//   let c = [a, b];
//   c.sort((x, y) => x.length - y.length);



// dictionary
// hasOwnProperty <- if its in dictionary
// k in dict also works