let s = "Knowledge, of built-in JavaScript methods, speeds up a tester's work.";
let newS;

console.log(s);
// Output: "Knowledge, of built-in JavaScript methods, speeds up a tester's work."

newS = s.length;
// Returns the length of the string
// Output: 69

newS = s.charAt(0);
// Returns the character at index 0
// Output: "K"

newS = s[0];
// Another way to get the character at index 0
// Output: "K"

newS = s.charCodeAt(0);
// Returns the Unicode of the character at index 0
// Output: 75

newS = s.at(0);
// Returns the character at index 0 (ES2022 feature)
// Output: "K"

newS = s.charAt(s.length - 3);
// Returns the third character from the end
// Output: "o"

newS = s.substring(2, 5);
// Extracts characters from index 2 to 4
// Output: "owl"

newS = s.substr(1, 3);
// Extracts 3 characters starting from index 1 (Deprecated)
// Output: "now"

newS = s.slice(1, 4);
// can also use negative num
// Extracts characters from index 1 to 3
// Output: "now"

newS = s.slice(-3);
// Extracts the last 3 c
// Sorting strings:
//   let c = [a, b];
//   c.sort((x, y) => x.length - y.length);


// const name = "James";
// switch (name){
//     case "Mark":
//         console.log("Hi");
//     case "James":
//         console.log("Bye");
//         break;
//     default:
//         console.log("Yes");
// }


// break, continue
// do {} while()
// try, catch, finally

// Math
// Math.abs Math.floor Math.ceil Math.random, Math.min Math.max

// General methods
// num.toString() -> int to str
// isNaN <- if its not int isNan(23)
// isInteger -> check if its int
// toFixed -> round (35).toFixed(2) - > 35.00
// parseInt <- str to int


//map, reduce, filter
// divisibleBy = (n, f) => n.filter(num => num % f === 0)
// name.split(' ').map(i => i[0].toUpperCase()).join('.')
// arr.reduce((acc, cur) => acc + cur, 0)


// Set
// set-> has()
// "#".repeat(cc.slice(0, -4).length)


// Lists/array
// concat() <- expand list
// push -> end 
// unshift -> beginning 
// pop last
// shift -> first pop
// delete arr[2] index delete makes empty but doesnt shortens arr
// .at -> we can use negative numbers for the ind from the end
// toString() -> arr to str
// .split() <- need to input space by default
// .join() <- arr to string
// JSON.stringify <- to compare arrs
// includes() <- if its in arr
// indexOf() <- index of item in arr -1 if not found
// find() <- returns the first element that satisfies the provided testing function.
// findIndex() <- returns the index of the first element that satisfies the provided testing function.
// filter() <- creates a new array with all elements that pass the test implemented by the provided function.
// slice() <- returns a shallow copy of a portion of an array into a new array object
// splice() <- changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.
// reverse() <- reverses the order of the elements of an array in place
// sort() <- sorts the elements of an array in place and returns the sorted array.
// fill() <- fills all the elements of an array from a start index to an end index
// every() <- tests whether all elements in the array pass the test implemented by the provided function
// some() <- tests whether at least one element in the array passes the test implemented by the provided function
// reduce() <- executes a reducer function (that you provide) on each element of the array, resulting in a single output value
// map() <- creates a new array populated with the results of calling a provided function on every element in the calling array

// arr1.concat(arr2) <- extend arr
// arr = [...ar1, ...ar2] <- extend too
// arr = [...ar, ...(isSummer? [1,2,3]:[])]
// str to arr-> [...str]

//Sorting Arrs
//numbers.sort((a, b) => a - b); // Ascending
//numbers.sort((a, b) => b - a); // Descending
//   let c = [a, b];
//   c.sort((x, y) => x.length - y.length);

// for (let value of array) <- iterate values
// for (let key in object) <- iterate keys 

// array.forEach(value => {
//     num += value;
//   });



// dictionary
// hasOwnProperty <- if its in dictionary
// k in dict also works